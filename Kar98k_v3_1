# 导入函数库
import numpy as np
import pandas as pd
import datetime
import talib
import matplotlib.pyplot as plt


'''
================================================================================
总体回测前
================================================================================
'''

#4
# 每小时开始时执行的函数
def on_hour_start(context):
    g.alternative_stocks_df = set_alternative_stocks(g.feasible_stocks, context)
    if g.alternative_stocks_df.empty:
        print "\nNo alternative stocks."
    else:
        print "\n%s" % g.alternative_stocks_df

def initialize(context):
    #1 设置参数
    set_params()
    #2 设置全局变量
    set_variables()
    #3 设置回测
    set_backtest()
    #4 每小时开始时执行的函数
    run_daily(on_hour_start, '10:30')
    run_daily(on_hour_start, '13:00')
    run_daily(on_hour_start, '14:00')

#1
# 设置参数
def set_params():
    g.data_length_for_index = 120  # 用于计算指标的样本长度
    g.cross_threshold = {'golden': 40, 'death': 70}  # 用于判定金叉/死叉数值有效性的阈值
    g.stop_profit_threshold = np.array([[10, 2], [8, 1.5], [6, 1], [5, 1.5], [4, 2], [float('-inf'), 4]])  # 用于止盈的阈值对照表：[涨幅，止盈回撤率]
    g.stop_loss_threshold = -3 # 用于无条件止损的阈值：涨幅

#2
# 设置全局变量    
def set_variables():
    g.feasible_stocks = []
    g.current_stocks = []
    g.if_trade_finished = False
    
#3
# 设置回测条件
def set_backtest():
    set_option('use_real_price', True) #用真实价格交易
    log.set_level('order', 'error')
    
    
'''
================================================================================
每天开盘前
================================================================================
'''

def before_trading_start(context):
    print "---------------------------------------------"
    #5 设置滑点与手续费
    set_slip_fee(context)
    # 过滤掉当日停牌的股票，并筛选出前5个交易日未曾停牌的非ST类股票
    g.feasible_stocks = set_feasible_stocks(5, context)
    # 进一步筛选
    g.alternative_stocks_df = set_alternative_stocks(g.feasible_stocks, context)
    if g.alternative_stocks_df.empty:
        print "\nNo alternative stocks."
    else:
        print "\n%s" % g.alternative_stocks_df
    # 获取仓内股票
    g.current_stocks = context.portfolio.positions.keys()
    g.if_trade_finished = False
    
#5
# 设置滑点与手续费
def set_slip_fee(context):
    # 将滑点设置为0.01
    set_slippage(FixedSlippage(0.01))
    # 设置手续费
    set_order_cost(OrderCost(open_tax=0, close_tax=0.001, open_commission=0.0003, close_commission=0.0003, close_today_commission=0, min_commission=5), type='stock')
    
#5
# 设置可行股票池
# 过滤掉当日停牌的股票，并筛选出前days个交易日未曾停牌的股票
# 输入类型：days: int, context(见API)
# 输出类型：list
def set_feasible_stocks(days, context):
    # 将所有股票（转换成列表）记录在stock_list中
    stock_list = list(get_all_securities(types=['stock'], date=context.current_dt).index)
    # 得到当日未停牌且非ST类的股票的list
    current_data = get_current_data()
    unsuspended_stocks = [stock for stock in stock_list if not current_data[stock].paused and not current_data[stock].is_st]
    # 进一步筛选
    feasible_stocks = []
    for stock in unsuspended_stocks:
        # 筛选出前days个交易日未曾停牌的非ST类股票list
        if sum(attribute_history(stock, days, '1d', ('paused'), skip_paused=False))[0]==0:
            past_prices = attribute_history(stock, g.data_length_for_index, '1d', ('close'))
            if not np.isnan(past_prices.iloc[0, 0]):
                feasible_stocks.append(stock)
    return feasible_stocks
    
#6
# 设置候选股票池
# （在可行股票池中）筛选出满足日线MACD红柱（DIF>DEA），以及日线KD在当天或前两个交易日内出现金叉的股票
# 输入类型：stock_list: list
# 输出类型：pandas.DataFrame
def set_alternative_stocks(stock_list, context):
    alternative_stocks_df = pd.DataFrame([], index=['daily KD GC position', 'hourly KD DC/GC position'])
    for stock in stock_list:
        # filter 1
        if if_in_long_trend(stock, '60m', [5, 10, 20, 60], 3, context):
            # filter 2
            filter_2 = if_near_KD_cross(stock, '1d', 'golden', 2, g.cross_threshold, g.data_length_for_index)
            if filter_2 > 0:
                # filter 3
                filter_3_1 = if_near_KD_cross(stock, '60m', 'death', 16, g.cross_threshold, g.data_length_for_index)
                filter_3_2 = if_near_KD_cross(stock, '60m', 'golden', 4, g.cross_threshold, g.data_length_for_index)
                if filter_3_1 > 0 or filter_3_2 > 0:
                    alternative_stocks_df[stock] = [filter_2, (filter_3_1, filter_3_2)]
    return alternative_stocks_df.T

#7
# 对候选股票进行评级
# 根据小时线KD前一个金叉出现时间的早晚，对各个候选股票进行评级
# 输入类型：stocks_df: pandas.DataFrame
# 输出类型：pandas.DataFrame
def rate_alternative_stocks(stock_df, context):
    for stock in list(stock_df.index):
        stock_df.loc[stock, 'ready_to_buy'] = if_in_long_trend(stock, '5m', [5, 10, 20], 6, context, is_static=False)
        
    return stock_df
    
    

'''
================================================================================
每分钟交易时
================================================================================
'''

# 每分钟调用一次
def handle_data(context, data):
    if g.if_trade_finished:
        return
    if g.alternative_stocks_df.empty:
        excellent_stocks = []
    else:
        # 当5分钟线多头排列时，可以准备买入
        g.alternative_stocks_df = rate_alternative_stocks(g.alternative_stocks_df, context)
        g.alternative_stocks_df.sort(['ready_to_buy', 'daily KD GC position'],
                                     ascending=[False, True], inplace=True)
        excellent_stocks = list(g.alternative_stocks_df[g.alternative_stocks_df.ready_to_buy == 1].index)
    if len(excellent_stocks) > 0:
        log.info("List of excellent stocks now (number %d):" % len(excellent_stocks))
        print "\n%s" % g.alternative_stocks_df
        if len(g.current_stocks) == 2:
            if context.portfolio.positions[g.current_stocks[0]].init_time < context.portfolio.positions[g.current_stocks[1]].init_time:
                stock = g.current_stocks[0]
            else:
                stock = g.current_stocks[1]
            order_target(stock, 0)
            log.info("Ready to buy a new stock. Selling %s" % stock)
        # 获取当前的现金数额
        cash = context.portfolio.available_cash
        if len(g.current_stocks) == 0:
            order_target_value(excellent_stocks[0], cash/2)
        else:
            order_target_value(excellent_stocks[0], cash)
        log.info("Buying %s" % excellent_stocks[0])
        g.if_trade_finished = True
    else:
        for stock in g.current_stocks:
            if stop_profit(stock, g.stop_profit_threshold, context) or stop_loss(stock, g.stop_loss_threshold, context):
                order_target(stock, 0)
                log.info("Stop profit/loss. Selling %s" % stock)
                g.current_stocks.remove(stock)
                break
    
def if_in_long_trend(stock, unit, MA_types, in_trend_units, context, is_static=True):
    # 获取过去的价格数据
    if is_static:
        necessary_price_units = max(MA_types) + in_trend_units - 1
        entire_past_prices = attribute_history(stock, necessary_price_units, unit, ('close'))
    else:
        start_date = context.previous_date
        start_time = datetime.datetime.strptime(str(start_date)+' 09:30:00','%Y-%m-%d %H:%M:%S')
        end_time = context.current_dt
        entire_past_prices = get_price(stock, start_date=start_time, end_date=end_time, frequency=unit, fields='close')
    # 对于需要确认均线排列情况的每一个时间单位
    for i in range(in_trend_units):
        # 筛去尾部的i个时间单位的数据
        if i == 0:
            past_prices = entire_past_prices
        else:
            past_prices = entire_past_prices[: -i]
        # 对于每种均线，截取数据计算均值并记录于list
        MA_values = []
        for MA_len in MA_types:
            MA_data = past_prices['close'][-MA_len:]
            MA_values.append(MA_data.mean())
        # 从大到小排列均值list
        sorted_MA_values = sorted(MA_values)
        sorted_MA_values.reverse()
        # 若排列之后和原先不同，说明均线在该点并未多头排列，函数返回False
        if MA_values != sorted_MA_values:
            return False
    # 若每一点处都确认均线多头排列，函数返回True
    return True

    
#8
# MACD函数，返回最后一个MACD值
# 输入类型：prices: numpy.ndarray (or ndarray-like)
# 输出类型：float
def MACD(prices, fastperiod=12, slowperiod=26, signalperiod=9):
    dif, dea, macd = talib.MACD(prices, 
                                fastperiod=fastperiod, 
                                slowperiod=slowperiod, 
                                signalperiod=signalperiod)
    return macd[-1]

#9
# KD函数，返回K和D的序列
# 输入类型：high, low, close: numpy.ndarray (or ndarray-like)
# 输出类型：numpy.ndarray, numpy.ndarray
def KD(high, low, close, fastk_period=9, slowk_period=3, slowd_period=3):
	array_len = high.size
	K, D = [50], [50]
	for i in range(array_len - fastk_period + 1):
		highest = np.max(high[i: fastk_period+i])
		lowest = np.min(low[i: fastk_period+i])
		close_today = close[fastk_period+i-1]
		if highest != lowest:
			RSV = (close_today - lowest) / (highest - lowest) * 100
		else:
			RSV = 50
		K.append((K[-1] * (slowk_period-1) + RSV) / float(slowk_period))
		D.append((D[-1] * (slowd_period-1) + K[-1]) / float(slowd_period))
	return np.array(K), np.array(D)

#10
# 确定金叉/死叉位置的函数，返回位置，0表示尚未出现，正整数表示出现的天数
# 输入类型：fastline, slowline: numpy.ndarray (ndarray-like), cross_types: 'golden' or 'death'
# 输出类型：int
def locate_cross(fastline, slowline, cross_type):
    diff_is_positive = list((fastline - slowline) > 0)
    diff_is_positive.reverse()
    if cross_type == 'golden':
        return diff_is_positive.index(0)
    elif cross_type == 'death':
        return diff_is_positive.index(1)
    else:
        log.error("Wrong Cross Type Input. Should be golden or death.")
        return
    
def if_near_KD_cross(stock, unit, cross_type, max_distance, cross_threshold, data_length):
    # 获取过去的价格数据
    past_prices = attribute_history(stock, data_length, unit, ('close', 'high', 'low'))
    # 计算对应的KD值（#9）
    K, D = KD(past_prices['high'].values, past_prices['low'].values, past_prices['close'].values)
    # 确定金叉/死叉出现的时间
    cross_pos = locate_cross(K, D, cross_type)
    # 若金叉/死叉出现不久（在给定距离内），且数值低于有效阈值，函数返回金叉/死叉出现的时间（正整数），否则返回0
    if 0 < cross_pos <= max_distance and D[-cross_pos] < cross_threshold[cross_type]:
        return cross_pos
    else:
        return 0
    

#11
# 计算最大回撤率的函数，返回最大回撤率（不包括%）
# 输入类型：prices: numpy.ndarray (or ndarray-like)
# 输出类型：float, int, int
def percentage_change(new, original):
    return (new - original) / float(original) * 100

#12
# 按照所给的阈值对照表判断一只股票是否需要止盈，返回是或否
# 输入类型：stock: str, threshold: numpy.ndarray, context(见API)
# 输出类型：bool
def stop_profit(stock, threshold, context):
    start_time = context.portfolio.positions[stock].init_time
    end_time = context.current_dt
    prices_1m = get_price(stock, start_date=start_time, end_date=end_time, frequency='1m', fields='close')
    peak_idx = np.argmax(prices_1m['close'].values)
    highest_profit_rate = percentage_change(prices_1m['close'][peak_idx], prices_1m['close'][0])
    drawdown_rate = -percentage_change(prices_1m['close'][-1], prices_1m['close'][peak_idx])
    for i in range(threshold.shape[0]):
        if highest_profit_rate > threshold[i, 0] and drawdown_rate > threshold[i, 1]:
            print "Stop profit. Peak %.2f: profit %.2f %%, now %.2f: drawdown %.2f %%." % (prices_1m['close'][peak_idx], highest_profit_rate, prices_1m['close'][-1], drawdown_rate)
            return True
    return False
        
#13
# 按照所给的阈值判断一只股票是否需要止损（最高级），返回是或否
# 输入类型：stock: str, threshold: float, context(见API)
# 输出类型：bool
def stop_loss(stock, threshold, context):
    start_time = context.portfolio.positions[stock].init_time
    end_time = context.current_dt
    prices_1m = get_price(stock, start_date=start_time, end_date=end_time, frequency='1m', fields='close')
    profit_rate = percentage_change(prices_1m['close'][-1], prices_1m['close'][0])
    if profit_rate < threshold:
        print "Stop loss. Profit rate: %.2f %%." % profit_rate
        return True
    else:
        return False
